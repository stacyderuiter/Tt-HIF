---
title: "Supplemental Materials for: Heat increment of feeding in the common bottlenose dolphin (*Tursiops truncatus*) is a minor quantity in estimating field metabolic rate"
author:
  - name: I. Koliopoulou
    affiliations:
      - ref: LU
  - name: S.L. DeRuiter
    affiliations:
      - ref: Calvin
  - name: J. Altimiras
    affiliations:
      - ref: LU
  - name: J. Larsson
    affiliations:
      - ref: KWP
  - name: J. Aranaz
    affiliations:
      - ref: FO 
  - name: D. Rosen
    affiliations:
      - ref: UBC
  - name: A. Fahlman
    affiliations:
      - ref: LU
      - ref: FO
      - ref: GDR      
affiliations:
  - id: LU
    name: Linkoping University
    city: Linkoping
    state: Sweden
  - id: Calvin
    name: Department of Mathematics and Statistics, Calvin University
    city: Grand Rapids
    state: MI USA
  - id: KWP
    name: Kolmarden Wildlife Park
    city: Kolmarden
    state: Sweden
  - id: FO
    name: Fundacion Oceanografic
    city: Valencia
    state: Spain
  - id: UBC
    name: Univeristy of British Columbia
    city: Vancouver
    state: British Columbia Canada
  - id: GDR
    name: Global Diving Research SL
    city: Valencia
    state: Spain
format: 
  html:
    embed-resources: true
  typst: default
toc: true
editor: source
---

# R Setup

```{r}
#| label: setup
#| message: false

library(mgcv)
library(ggformula)
library(tidyverse)
library(readxl)
library(ggeffects)
library(pracma)
library(DHARMa)
library(gt)
library(gtsummary)
library(mixedup)

knitr::opts_chunk$set(echo = TRUE,
                      fig.width = 6,
                      fig.height = 4.5,
                      fig.path = "figures/HIF-",
                      dev = "jpeg",
                      dpi = 300)

theme_set(theme_minimal(base_size = 12))
```

# Data Preparation

```{r}
HIF_data <- read_xlsx('data/updated_data.xlsx',
                      .name_repair = 'unique_quiet') |>
  mutate(animal = factor(animal),
         day = factor(interaction(animal, date, drop = TRUE)),
         # numeric version of binary sex variable 
         # (this doesn't change model parameter estimates but
         # eases later predictions from fitted model)
         is_male = if_else(sex == "M", 1,0))
```

# HIF Model

## Model fitting


```{r}
HIF_model <- gam(oxygen_cons ~ 
                   # smooth terms
                   s(exact, k = 4, bs = "ts") +
                   s(percentdailytotal, k = 4, bs = "ts") +
                   ti(exact, percentdailytotal, k = 4, bs = "ts") + 
                   s(body_mass, k = 4, bs = "ts") +
                   s(age, k = 4, bs = "ts") + 
                   # other predictor(s)
                   # treat sex as logical 0/1 for convenience later when predicting
                   is_male + 
                   s(pool_temp, k = 4, bs = "ts") +
                   # random effects
                   s(animal, bs = "re") + 
                   s(day, bs = "re"),
                 data = HIF_data, 
                 # to use ANOVA for hypothesis testing after model fitting
                 method = "ML", 
                 # to avoid overfitting and allow penalization of smooths
                 # to flat lines if needed
                 select = TRUE)
```

Standard model summary output from `gam()`:

```{r}
summary(HIF_model)
```

A prettier model summary table:

```{r}
tbl_regression(HIF_model)
```

## Model Checking

Below are `mgcv` package checks for GAMs, presented mainly to view model convergence and basis dimension checking results.

```{r}
#| label: gam-check
#| fig-show: "hide"

gam.check(HIF_model)
```

### Residual Histogram

This graph allows us to verify the residual normality condition.

```{r}
#| label: residual-histogram

gf_dhistogram(~resid(HIF_model), bins = 15) |> 
  gf_fitdistr(dist = "dnorm")
```

### Scaled Residual Plot

The scaled residual plot (Hartig, 2024) allows verification that the mean-variance relationship is as expected, particularly for mixed-effect models and generalized linear models. If all is well, scaled residuals will be trendless and will have uniform spread between 0-1 for all fitted values.

```{r}
#| label: scaled-resids
#| message: false

plotResiduals(simulateResiduals(HIF_model), quantreg = FALSE)
```

### Residual ACF Plot

The ACF plot allows us to verify the residual independence condition.

```{r}
#| label: residual-acf

acf(resid(HIF_model))
```

## Model Interpretation

### Hypothesis Testing

Type II ANOVA allows us to test the null hypothesis of no association with the response, for each predictor (and interaction) included in the model.

```{r}
anova(HIF_model)
```

### Variance Term Estimation

For random intercept terms, by analogy with the way that mixed-effect model results are usually reported and light of the fact that we wish to control for any individual or day-to-day effects rather than performing hypothesis testing for them, it is possible to report the standard variance components associated with each term. They are shown below (in units of standard deviation). Note that since we used maximum-likelihood estimation, these estimates may be biased for finite sample size, but since variance term estimation is not the focus of inference (and smooth term hypothesis testing is) this seems like the right choice in our case. 

```{r}
#| results: hide

vars <- invisible(gam.vcomp(HIF_model)) 

vars <- vars |>
  data.frame() |>
  mutate(
    Term = rownames(vars),
    Term = ifelse(Term == "scale", "scale (residuals)", Term)
  ) |>
rename(`Standard Deviation` = std.dev,
       `CI (lower)` = lower,
       `CI (upper)` = upper
       ) |>
  select(Term,
         `Standard Deviation`, 
         `CI (lower)`, 
         `CI (upper)`) |>
  mutate(across(where(is.numeric), function(x) signif(x, 3))) |>
  gt()
```

```{r}
vars
```

### Model prediction note

A way of visualizing the results of a GAM (or other regression model) is a prediction plot, where you select specific values at which to fix all the predictors other than `exact` time (age, proportion total calories, etc.) and then show predicted oxygen consumption according to the model -- given those fixed values, and varying values of exact. Such a plot might be preferable to a partial plot because the y-axis is in terms of expected response variable values (in total, not a contribution to the whole from one predictor).

We used marginal means of "other" predictors; in this approach quantitative predictors are set to the mean value observed in the data, and for categorical predictors a weighted average across the observed values is used. 

Random effects terms are not included, so that predictions are population-level (or, equivalently here, predictions for the typical dolphin on the typical day). 

The idea is to try to show the expected response value for "an average observation" (in some sense) in the population, given the actual sample data and assuming the data is a reasonable sample of the population of interest. So, it may make the some sense as a set of predictions that can be overlaid on a plot of the data.

### Marginal Means of Model Variables

We'd like to make model predictions with all predictors except for the time since feeding held constant at their mean values. What are those mean values?

```{r}
model_vars <- c('exact',
                'percentdailytotal',
                'body_mass',
                'pool_temp',
                'age',
                'sex')

tbl_summary(
    data = HIF_data,
    statistic = list(all_continuous() ~ "{mean} ({sd})", 
                      all_categorical() ~ "{n} ({p}%)"),
    type = list(all_continuous() ~ "continuous",
                all_categorical() ~ "categorical",
                age ~ "continuous"),
    # type = assign_summary_type(variables = model_vars,
    #                            cat_threshold = 3,
    #                            value = NULL),
    include = all_of(model_vars)
  )
```


### Predictions with uncertainty
To compute model-predicted oxygen consumption and total oxygen consumption (area under the curve), all with uncertainty, we can employ a resampling-based approach.

We use `mgcv::gam.mh()` to draw samples of model parameter values via Metropolis-Hastings sampling from the posterior.

We obtain a linear-predictor matrix from the fitted model, which when post-multiplied by a vector of candidate parameter values, yields predictions from the fitted model for the chosen mean values of predictor variables (and varying values of `exact` time).

By generating these predictions for many parameter samples, we can obtain model predictions and derived quantities with uncertainty (here, percentile-based confidence intervals and standard errors are computed).

```{r}
nsim <- 10000
set.seed(14)

# draws of parameter estimates from the posterior
actual_params <- matrix(coef(HIF_model), nrow = 1)
post_params <- gam.mh(HIF_model, ns = nsim*2, burn = 2000, thin = 2)$bs
# yields matrix with cols = model params and rows = sim #s

# get linear predictor matrix for "mm data"
mm_const <- HIF_data |> 
  select(percentdailytotal, 
         body_mass,
         age,
         pool_temp,
         is_male) |>
  summarise(across(everything(), function(x) mean(x)))

mm_df <- expand_grid(mm_const,
                     exact = seq(from = 0, by = 1, to = 133)) 

mm_lpmat <- predict(HIF_model,
        newdata = mm_df,
        type="lpmatrix",
        exclude = c("s(animal)", "s(day)"),
        newdata.guaranteed = TRUE)

# get predicted vo2 values (each col is one sim)
vo2_curve <- mm_lpmat %*% t(post_params) ## posterior curve samples
vo2_curve_actual <- mm_lpmat %*% t(actual_params)

# mean and 95% CI
vo2_predictions <- mm_df |>
  mutate(pred = apply(vo2_curve, 
                    MARGIN = 1,
                    FUN = mean),
         ci_low = apply(vo2_curve, 
                    MARGIN = 1,
                    FUN = function(x) quantile(x, 0.025)),
         ci_hi = apply(vo2_curve, 
                    MARGIN = 1,
                    FUN = function(x) quantile(x, 0.975)))
```

```{r}
compute_auc <- function(predicted_smooth, x = mm_df$exact){
  AUC = cumtrapz(x = x,
                 y = predicted_smooth)
  total_AUC <- max(AUC)
  return(total_AUC)
}
```


```{r}

vo2_totals <- apply(vo2_curve, 
                    MARGIN = 2,
                    FUN = compute_auc)
vo2_totals_actual <- compute_auc(vo2_curve_actual)

# as percent, assuming BMR is constant
BMR_133 <- vo2_curve[mm_df$exact == 0,] * 133
BMR_daily <- BMR_133 * (24 * 60 / 133)
# 1051.2 # L O2 in one day

HIF_133 <- vo2_totals - BMR_133
daily_HIF <- HIF_133 / mm_const$percentdailytotal
daily_HIF_percent <- (daily_HIF / BMR_daily) * 100

```

Histogram of simulation results:

```{r}
#| label: sim-total-vo2

gf_histogram(~vo2_totals) |>
  gf_labs(x = "Liters Oxygen Consumed (over 133 minutes)",
          y = "Number of Simulations")
```

```{r}
#| label: sim-total-vo2-percent

gf_histogram(~daily_HIF_percent) |>
  gf_labs(x = "HIF (percent of daily BMR)",
          y = "Number of Simulations")
```

Calculations of specific values of interest:

oxygen consumption over the 133 minutes:

```{r}
vo2_mean <- round(mean(vo2_totals), digits = 2)
vo2_se <- round(sd(vo2_totals), digits = 2)

vo2_mean
vo2_se
```

daily HIF total:

```{r}
HIF_daily <- round(mean(daily_HIF), digits = 2)
HIF_daily_se <- round(sd(daily_HIF), digits = 2)
HIF_daily
HIF_daily_se
```

daily HIF as percent:

```{r}
vo2_percent_mean <- round(mean(daily_HIF_percent), digits = 2)
vo2_percent_se <- round(sd(daily_HIF_percent), digits = 2)

vo2_percent_mean
vo2_percent_se
```

BMR over 24h:

```{r}
BMR_daily_mean <- round(mean(BMR_daily), digits = 2)
BMR_daily_se <- round(sd(BMR_daily), digits = 2)
BMR_daily_mean
BMR_daily_se
```


over 133 minutes, using the BMR at time 0:

```{r}
# at time 0
mean(vo2_curve[mm_df$exact == 0,] * 133)
sd(vo2_curve[mm_df$exact == 0,] * 133)
```


The mean (standard deviation) of the simulated values is: `r round(mean(vo2_totals), digits = 2)` (`r vo2_se`) liters. 

The mean (standard deviation) of the simulated percentages is: `r round(mean(daily_HIF_percent), digits = 2)` (`r vo2_percent_se`).

For additional reference if needed, the initial value of oxygen consumption at time 0 is: `r round(vo2_predictions$pred[vo2_predictions$exact == 0], digits = 2)` (se `r round(sd(vo2_curve[mm_df$exact == 0,]), digits = 3)`), and so over the whole 133 minutes, `r round(vo2_predictions$pred[vo2_predictions$exact == 0] * 133, digits = 2)` (se `r round(sd(vo2_curve[mm_df$exact == 0,] * 133), digits = 2)`)

#### Data Plot with Model Fit

Define colors and shapes to use for plotting

```{r}
kcal_colors <- c("#E41A1C", "#377EB8", "#4DAF4A", "#984EA3")
shape_vector <- c("Tt1" = 1, "Tt2" = 2, "Tt3" = 3, "Tt4" = 4, 
                  "Tt5" = 5, "Tt6" = 6, "Tt7" = 7, "Tt8" = 8)
```


```{r}
#| label: data-plus-gam

oxygen_time_plot <- ggplot(HIF_data, 
                           aes(x = exact, y = oxygen_cons)) +
  geom_point(aes(color = factor(kcal), shape = animal), 
             size = 1, 
             stroke = 1.2) +
  geom_line(data = vo2_predictions,
            aes(x = exact, y = pred),
            color = 'black',
            linewidth = 1) +
  geom_ribbon(data = vo2_predictions,
              aes(ymin = ci_low, ymax = ci_hi, x = exact),
              inherit.aes = FALSE,
              fill = 'grey44', alpha = 0.2) +
  labs(x = "Time (min)", 
       y = "Oxygen Consumption (L / min)", 
       color = "Energy Intake (kcal)", 
       shape = "Animal ID") +
  scale_color_manual(values = kcal_colors) +
  scale_shape_manual(values = shape_vector) +
  theme_minimal() +
  theme(axis.text = element_text(size = 12),
        axis.title = element_text(size = 14),
        axis.line = element_line(linewidth = 1)) +
  scale_x_continuous(breaks = seq(0, 120, by = 20)) +
  scale_y_continuous(breaks = seq(0, 2, by = 0.2))

print(oxygen_time_plot)
```

# References

Hartig F (2024). *DHARMa: Residual Diagnostics for Hierarchical (Multi-Level / Mixed) Regression Models*. R package version 0.4.7, <https://CRAN.R-project.org/package=DHARMa>.
